import fs from 'fs';
import path from 'path';
import express from 'express';
import cors from 'cors';
import esbuild from 'esbuild';
import axios from 'axios';
import { URL } from 'url';

function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function asyncGeneratorStep(n, t, e, r, o, a, c) {
  try {
    var i = n[a](c),
      u = i.value;
  } catch (n) {
    return void e(n);
  }
  i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator(n) {
  return function () {
    var t = this,
      e = arguments;
    return new Promise(function (r, o) {
      var a = n.apply(t, e);
      function _next(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "next", n);
      }
      function _throw(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "throw", n);
      }
      _next(void 0);
    });
  };
}
function _createForOfIteratorHelperLoose(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (t) return (t = t.call(r)).next.bind(t);
  if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
    t && (r = t);
    var o = 0;
    return function () {
      return o >= r.length ? {
        done: !0
      } : {
        done: !1,
        value: r[o++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _regeneratorRuntime() {
  _regeneratorRuntime = function () {
    return e;
  };
  var t,
    e = {},
    r = Object.prototype,
    n = r.hasOwnProperty,
    o = Object.defineProperty || function (t, e, r) {
      t[e] = r.value;
    },
    i = "function" == typeof Symbol ? Symbol : {},
    a = i.iterator || "@@iterator",
    c = i.asyncIterator || "@@asyncIterator",
    u = i.toStringTag || "@@toStringTag";
  function define(t, e, r) {
    return Object.defineProperty(t, e, {
      value: r,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), t[e];
  }
  try {
    define({}, "");
  } catch (t) {
    define = function (t, e, r) {
      return t[e] = r;
    };
  }
  function wrap(t, e, r, n) {
    var i = e && e.prototype instanceof Generator ? e : Generator,
      a = Object.create(i.prototype),
      c = new Context(n || []);
    return o(a, "_invoke", {
      value: makeInvokeMethod(t, r, c)
    }), a;
  }
  function tryCatch(t, e, r) {
    try {
      return {
        type: "normal",
        arg: t.call(e, r)
      };
    } catch (t) {
      return {
        type: "throw",
        arg: t
      };
    }
  }
  e.wrap = wrap;
  var h = "suspendedStart",
    l = "suspendedYield",
    f = "executing",
    s = "completed",
    y = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var p = {};
  define(p, a, function () {
    return this;
  });
  var d = Object.getPrototypeOf,
    v = d && d(d(values([])));
  v && v !== r && n.call(v, a) && (p = v);
  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t) {
    ["next", "throw", "return"].forEach(function (e) {
      define(t, e, function (t) {
        return this._invoke(e, t);
      });
    });
  }
  function AsyncIterator(t, e) {
    function invoke(r, o, i, a) {
      var c = tryCatch(t[r], t, o);
      if ("throw" !== c.type) {
        var u = c.arg,
          h = u.value;
        return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
          invoke("next", t, i, a);
        }, function (t) {
          invoke("throw", t, i, a);
        }) : e.resolve(h).then(function (t) {
          u.value = t, i(u);
        }, function (t) {
          return invoke("throw", t, i, a);
        });
      }
      a(c.arg);
    }
    var r;
    o(this, "_invoke", {
      value: function (t, n) {
        function callInvokeWithMethodAndArg() {
          return new e(function (e, r) {
            invoke(t, n, e, r);
          });
        }
        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(e, r, n) {
    var o = h;
    return function (i, a) {
      if (o === f) throw Error("Generator is already running");
      if (o === s) {
        if ("throw" === i) throw a;
        return {
          value: t,
          done: !0
        };
      }
      for (n.method = i, n.arg = a;;) {
        var c = n.delegate;
        if (c) {
          var u = maybeInvokeDelegate(c, n);
          if (u) {
            if (u === y) continue;
            return u;
          }
        }
        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
          if (o === h) throw o = s, n.arg;
          n.dispatchException(n.arg);
        } else "return" === n.method && n.abrupt("return", n.arg);
        o = f;
        var p = tryCatch(e, r, n);
        if ("normal" === p.type) {
          if (o = n.done ? s : l, p.arg === y) continue;
          return {
            value: p.arg,
            done: n.done
          };
        }
        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
      }
    };
  }
  function maybeInvokeDelegate(e, r) {
    var n = r.method,
      o = e.iterator[n];
    if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
    var i = tryCatch(o, e.iterator, r.arg);
    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
    var a = i.arg;
    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
  }
  function pushTryEntry(t) {
    var e = {
      tryLoc: t[0]
    };
    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
  }
  function resetTryEntry(t) {
    var e = t.completion || {};
    e.type = "normal", delete e.arg, t.completion = e;
  }
  function Context(t) {
    this.tryEntries = [{
      tryLoc: "root"
    }], t.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(e) {
    if (e || "" === e) {
      var r = e[a];
      if (r) return r.call(e);
      if ("function" == typeof e.next) return e;
      if (!isNaN(e.length)) {
        var o = -1,
          i = function next() {
            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
            return next.value = t, next.done = !0, next;
          };
        return i.next = i;
      }
    }
    throw new TypeError(typeof e + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), o(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
    var e = "function" == typeof t && t.constructor;
    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
  }, e.mark = function (t) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
  }, e.awrap = function (t) {
    return {
      __await: t
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
    void 0 === i && (i = Promise);
    var a = new AsyncIterator(wrap(t, r, n, o), i);
    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
      return t.done ? t.value : a.next();
    });
  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
    return this;
  }), define(g, "toString", function () {
    return "[object Generator]";
  }), e.keys = function (t) {
    var e = Object(t),
      r = [];
    for (var n in e) r.push(n);
    return r.reverse(), function next() {
      for (; r.length;) {
        var t = r.pop();
        if (t in e) return next.value = t, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, e.values = values, Context.prototype = {
    constructor: Context,
    reset: function (e) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
    },
    stop: function () {
      this.done = !0;
      var t = this.tryEntries[0].completion;
      if ("throw" === t.type) throw t.arg;
      return this.rval;
    },
    dispatchException: function (e) {
      if (this.done) throw e;
      var r = this;
      function handle(n, o) {
        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
      }
      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
        var i = this.tryEntries[o],
          a = i.completion;
        if ("root" === i.tryLoc) return handle("end");
        if (i.tryLoc <= this.prev) {
          var c = n.call(i, "catchLoc"),
            u = n.call(i, "finallyLoc");
          if (c && u) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          } else if (c) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
          } else {
            if (!u) throw Error("try statement without catch or finally");
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          }
        }
      }
    },
    abrupt: function (t, e) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var o = this.tryEntries[r];
        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
          var i = o;
          break;
        }
      }
      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
      var a = i ? i.completion : {};
      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
    },
    complete: function (t, e) {
      if ("throw" === t.type) throw t.arg;
      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
    },
    finish: function (t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
      }
    },
    catch: function (t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.tryLoc === t) {
          var n = r.completion;
          if ("throw" === n.type) {
            var o = n.arg;
            resetTryEntry(r);
          }
          return o;
        }
      }
      throw Error("illegal catch attempt");
    },
    delegateYield: function (e, r, n) {
      return this.delegate = {
        iterator: values(e),
        resultName: r,
        nextLoc: n
      }, "next" === this.method && (this.arg = t), y;
    }
  }, e;
}
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}

var getBaseFromBase64 = function getBaseFromBase64(type, messages) {
  var result = [];
  messages.forEach(function (message) {
    if (Array.isArray(message.content)) {
      message.content.forEach(function (contentItem) {
        if (contentItem.type === type) {
          var _contentItem$type$url = contentItem[type].url.split(","),
            contentType = _contentItem$type$url[0],
            base64 = _contentItem$type$url[1];
          result.push({
            type: contentType.split(":")[1].split(";")[0],
            base64: base64,
            fileName: contentItem[type].detail
          });
        }
      });
    }
  });
  return result;
};
/**
 * Detect file type from binary data using magic numbers
 * @param buffer - Buffer containing the file data
 * @returns File type info {mime: string, ext: string} or null if unknown
 */
/**
 * Detect file type from binary data or MIME type string
 * @param input - Either a Buffer containing file data or a MIME type string
 * @returns File type info {mime: string, ext: string} or null if unknown
 */
var detectFileType = function detectFileType(mime) {
  // If input is a string, assume it's a MIME type
  var mimeType = mime.toLowerCase().trim();
  // Common MIME types to extension mapping
  var mimeMapping = {
    "image/png": "png",
    "image/jpeg": "jpg",
    "image/jpg": "jpg",
    "image/gif": "gif",
    "image/webp": "webp",
    "image/svg+xml": "svg",
    "application/pdf": "pdf",
    "audio/mpeg": "mp3",
    "audio/mp3": "mp3",
    "video/mp4": "mp4",
    "video/mpeg": "mpg",
    "application/json": "json",
    "text/plain": "txt",
    "text/html": "html",
    "text/css": "css",
    "text/javascript": "js",
    "application/javascript": "js",
    "application/xml": "xml",
    "text/xml": "xml",
    "application/zip": "zip",
    "application/x-zip-compressed": "zip",
    "application/msword": "doc",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document": "docx",
    "application/vnd.ms-excel": "xls",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": "xlsx",
    "application/vnd.ms-powerpoint": "ppt",
    "application/vnd.openxmlformats-officedocument.presentationml.presentation": "pptx"
  };
  // Return known extension or extract from MIME type
  if (mimeMapping[mimeType]) {
    return mimeMapping[mimeType];
  }
  return null;
};
var parseDataUrl = function parseDataUrl(dataUrl) {
  if (!dataUrl || typeof dataUrl !== "string") {
    return null;
  }
  // Check if this is a valid data URL format
  var dataUrlRegex = /^data:([^;,]+)(;base64)?,(.*)/;
  var matches = dataUrl.match(dataUrlRegex);
  if (!matches || matches.length < 4) {
    return null;
  }
  return {
    mimeType: matches[1],
    base64: matches[3],
    buffer: Buffer.from(matches[3], "base64")
  };
};
/**
 * Creates a file from base64 data
 * @param base64 - The base64 string (without the data:image/png;base64, prefix)
 * @param fileName - Name for the created file
 * @param directory - Directory to store the file (default: 'tmp')
 * @param fileType - Optional MIME type (e.g., 'image/png')
 * @returns Promise with the full path to the created file
 */
var createFileFromBase64 = /*#__PURE__*/function () {
  var _ref = /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(base64, fileName, directory) {
    var data, mimeType, buffer, extension, safeFileName, filePath;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          if (directory === void 0) {
            directory = "tmp";
          }
          _context.next = 3;
          return fs.promises.mkdir(directory, {
            recursive: true
          });
        case 3:
          // Convert base64 to buffer
          // const buffer = Buffer.from(base64, "base64");
          data = parseDataUrl(base64);
          if (data) {
            _context.next = 6;
            break;
          }
          throw new Error("Invalid base64 data");
        case 6:
          mimeType = data.mimeType, buffer = data.buffer; // Auto-detect file type from buffer
          extension = mimeType ? detectFileType(mimeType) : ""; // Create a safe filename if not provided
          safeFileName = fileName || "file-" + Date.now() + "-" + Math.random().toString(36).substring(2, 10); // Add extension if not present in the filename
          if (path.extname(safeFileName) === "") {
            safeFileName = safeFileName + "." + extension;
          }
          // Generate file path
          filePath = path.join(directory, safeFileName); // Write buffer to file
          _context.next = 13;
          return fs.promises.writeFile(filePath, buffer);
        case 13:
          return _context.abrupt("return", filePath);
        case 14:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function createFileFromBase64(_x, _x2, _x3) {
    return _ref.apply(this, arguments);
  };
}();
/**
 * Creates files from the results of getBaseFromBase64
 * @param results - Array of Base64Result objects
 * @param directory - Directory to store the files (default: 'tmp')
 * @returns Promise with array of file paths
 */
var createFilesFromBase64Results = /*#__PURE__*/function () {
  var _ref2 = /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(results, directory) {
    var filePaths, _iterator, _step, result, filePath;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          if (directory === void 0) {
            directory = "tmp";
          }
          filePaths = [];
          _iterator = _createForOfIteratorHelperLoose(results);
        case 3:
          if ((_step = _iterator()).done) {
            _context2.next = 11;
            break;
          }
          result = _step.value;
          _context2.next = 7;
          return createFileFromBase64(result.base64, result.fileName || "file-" + Date.now() + "-" + Math.random().toString(36).substring(2, 10), directory);
        case 7:
          filePath = _context2.sent;
          filePaths.push(filePath);
        case 9:
          _context2.next = 3;
          break;
        case 11:
          return _context2.abrupt("return", filePaths);
        case 12:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return function createFilesFromBase64Results(_x4, _x5) {
    return _ref2.apply(this, arguments);
  };
}();
/**
 * Deletes a file if it exists
 * @param filePath - Path to the file to delete
 * @returns Promise<boolean> - True if file was deleted, false if file didn't exist
 */
var deleteFile = /*#__PURE__*/function () {
  var _ref3 = /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(filePath) {
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          _context3.prev = 0;
          _context3.next = 3;
          return fs.promises.access(filePath);
        case 3:
          _context3.next = 5;
          return fs.promises.unlink(filePath);
        case 5:
          return _context3.abrupt("return", true);
        case 8:
          _context3.prev = 8;
          _context3.t0 = _context3["catch"](0);
          if (!(_context3.t0.code === "ENOENT")) {
            _context3.next = 12;
            break;
          }
          return _context3.abrupt("return", false);
        case 12:
          throw _context3.t0;
        case 13:
        case "end":
          return _context3.stop();
      }
    }, _callee3, null, [[0, 8]]);
  }));
  return function deleteFile(_x6) {
    return _ref3.apply(this, arguments);
  };
}();
/**
 * Deletes multiple files
 * @param filePaths - Array of file paths to delete
 * @returns Promise<{deleted: string[], notFound: string[], failed: {path: string, error: string}[]}>
 */
var deleteFiles = /*#__PURE__*/function () {
  var _ref4 = /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(filePaths) {
    var results;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) switch (_context5.prev = _context5.next) {
        case 0:
          results = {
            deleted: [],
            notFound: [],
            failed: []
          };
          _context5.next = 3;
          return Promise.all(filePaths.map(/*#__PURE__*/function () {
            var _ref5 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(filePath) {
              var deleted;
              return _regeneratorRuntime().wrap(function _callee4$(_context4) {
                while (1) switch (_context4.prev = _context4.next) {
                  case 0:
                    _context4.prev = 0;
                    _context4.next = 3;
                    return deleteFile(filePath);
                  case 3:
                    deleted = _context4.sent;
                    if (deleted) {
                      results.deleted.push(filePath);
                    } else {
                      results.notFound.push(filePath);
                    }
                    _context4.next = 10;
                    break;
                  case 7:
                    _context4.prev = 7;
                    _context4.t0 = _context4["catch"](0);
                    results.failed.push({
                      path: filePath,
                      error: _context4.t0.message || String(_context4.t0)
                    });
                  case 10:
                  case "end":
                    return _context4.stop();
                }
              }, _callee4, null, [[0, 7]]);
            }));
            return function (_x8) {
              return _ref5.apply(this, arguments);
            };
          }()));
        case 3:
          return _context5.abrupt("return", results);
        case 4:
        case "end":
          return _context5.stop();
      }
    }, _callee5);
  }));
  return function deleteFiles(_x7) {
    return _ref4.apply(this, arguments);
  };
}();
/**
 * Cleans up temporary files in a directory
 * @param directory - Directory to clean
 * @param maxAge - Maximum age of files to keep (in milliseconds)
 * @returns Promise with deletion results
 */
var cleanupTempFiles = /*#__PURE__*/function () {
  var _ref6 = /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(directory, maxAge // Default: 24 hours
  ) {
    var files, now, filesToDelete, _iterator2, _step2, file, filePath, stats, fileAge;
    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) switch (_context6.prev = _context6.next) {
        case 0:
          if (directory === void 0) {
            directory = "tmp";
          }
          if (maxAge === void 0) {
            maxAge = 24 * 60 * 60 * 1000;
          }
          _context6.prev = 2;
          _context6.next = 5;
          return fs.promises.access(directory);
        case 5:
          _context6.next = 7;
          return fs.promises.readdir(directory);
        case 7:
          files = _context6.sent;
          now = Date.now();
          filesToDelete = []; // Check each file's age
          _iterator2 = _createForOfIteratorHelperLoose(files);
        case 11:
          if ((_step2 = _iterator2()).done) {
            _context6.next = 27;
            break;
          }
          file = _step2.value;
          filePath = path.join(directory, file);
          _context6.prev = 14;
          _context6.next = 17;
          return fs.promises.stat(filePath);
        case 17:
          stats = _context6.sent;
          fileAge = now - stats.mtimeMs;
          if (fileAge > maxAge) {
            filesToDelete.push(filePath);
          }
          _context6.next = 25;
          break;
        case 22:
          _context6.prev = 22;
          _context6.t0 = _context6["catch"](14);
          console.error("Error checking file " + filePath + ":", _context6.t0);
        case 25:
          _context6.next = 11;
          break;
        case 27:
          _context6.next = 29;
          return deleteFiles(filesToDelete);
        case 29:
          return _context6.abrupt("return", _context6.sent);
        case 32:
          _context6.prev = 32;
          _context6.t1 = _context6["catch"](2);
          if (!(_context6.t1.code === "ENOENT")) {
            _context6.next = 36;
            break;
          }
          return _context6.abrupt("return", {
            deleted: [],
            notFound: [],
            failed: []
          });
        case 36:
          throw _context6.t1;
        case 37:
        case "end":
          return _context6.stop();
      }
    }, _callee6, null, [[2, 32], [14, 22]]);
  }));
  return function cleanupTempFiles(_x9, _x10) {
    return _ref6.apply(this, arguments);
  };
}();
/**
 * Checks if a string is base64 encoded
 * @param str - The string to check
 * @param strict - Whether to perform strict validation (including decoding test)
 * @returns boolean - True if the string is base64 encoded, false otherwise
 */
var isBase64 = function isBase64(str, strict) {
  if (strict === void 0) {
    strict = false;
  }
  if (!str || typeof str !== "string") {
    return false;
  }
  // Check 1: String only contains valid base64 characters
  var base64Regex = /^[A-Za-z0-9+/]*={0,2}$/;
  if (!base64Regex.test(str)) {
    return false;
  }
  // Check 2: Length is valid (multiple of 4)
  if (str.length % 4 !== 0) {
    return false;
  }
  // Check 3: Padding (=) only appears at the end and at most 2
  var paddingMatch = str.match(/=*$/);
  if (paddingMatch && paddingMatch[0].length > 2) {
    return false;
  }
  // Check 4: If strict mode, try to decode it
  if (strict) {
    try {
      Buffer.from(str, "base64").toString();
      return true;
    } catch (error) {
      return false;
    }
  }
  return true;
};
/**
 * Checks if a string is a data URL
 * @param str - The string to check
 * @returns boolean - True if the string is a data URL, false otherwise
 */
var isDataUrl = function isDataUrl(str) {
  if (!str || typeof str !== "string") {
    return false;
  }
  var dataUrlRegex = /^data:([^;,]+)(;base64)?,/;
  return dataUrlRegex.test(str);
};
/**
 * Detects if a string is base64 or data URL and extracts base64 content
 * @param input - The string to check (could be base64 encoded string or data URL)
 * @returns Object with type and content, or null if not recognized
 */
var parseBase64Input = function parseBase64Input(input) {
  if (!input || typeof input !== "string") {
    return null;
  }
  // Check if it's a data URL
  if (isDataUrl(input)) {
    var parsed = parseDataUrl(input);
    if (!parsed) return null;
    return {
      type: "dataUrl",
      content: parsed.base64,
      mimeType: parsed.mimeType
    };
  }
  // Check if it's a plain base64 string
  if (isBase64(input)) {
    return {
      type: "base64",
      content: input
    };
  }
  return null;
};

var PORT_LOCAL_MODEL = 65534;
var PORT_AGENT_ROUTER = 33030;
var PORT_AGENT_PROMPT_BASE = 80;
var PORT_AGENT_STANDALONE = 8080;

var API_PROVIDER_URL = "https://agent-service.eternalai.org/api/v1";



var index = {
  __proto__: null,
  PORT_LOCAL_MODEL: PORT_LOCAL_MODEL,
  PORT_AGENT_ROUTER: PORT_AGENT_ROUTER,
  PORT_AGENT_PROMPT_BASE: PORT_AGENT_PROMPT_BASE,
  PORT_AGENT_STANDALONE: PORT_AGENT_STANDALONE,
  API_PROVIDER_URL: API_PROVIDER_URL
};

var getProviderInfo = /*#__PURE__*/function () {
  var _ref2 = /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var userAddress, response, responseBody;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          userAddress = _ref.userAddress;
          _context.prev = 1;
          _context.next = 4;
          return fetch(API_PROVIDER_URL + "/agent/wallet", {
            method: "POST",
            body: JSON.stringify({
              user_address: userAddress
            }),
            headers: {
              "Content-Type": "application/json"
            }
          });
        case 4:
          response = _context.sent;
          if (response.ok) {
            _context.next = 7;
            break;
          }
          throw new Error("Error fetching wallet: " + response.statusText);
        case 7:
          _context.next = 9;
          return response.json();
        case 9:
          responseBody = _context.sent;
          return _context.abrupt("return", responseBody.data);
        case 13:
          _context.prev = 13;
          _context.t0 = _context["catch"](1);
          throw new Error("Error fetching wallet: " + _context.t0);
        case 16:
        case "end":
          return _context.stop();
      }
    }, _callee, null, [[1, 13]]);
  }));
  return function getProviderInfo(_x) {
    return _ref2.apply(this, arguments);
  };
}();
var getWalletData = /*#__PURE__*/function () {
  var _ref3 = /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(apiKey) {
    var response, responseBody;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          _context2.prev = 0;
          _context2.next = 3;
          return fetch(API_PROVIDER_URL + "/agent/wallet/" + apiKey, {
            method: "GET",
            headers: {
              "Content-Type": "application/json"
            }
          });
        case 3:
          response = _context2.sent;
          if (response.ok) {
            _context2.next = 6;
            break;
          }
          throw new Error("Error fetching wallet: " + response.statusText);
        case 6:
          _context2.next = 8;
          return response.json();
        case 8:
          responseBody = _context2.sent;
          return _context2.abrupt("return", responseBody.data);
        case 12:
          _context2.prev = 12;
          _context2.t0 = _context2["catch"](0);
          throw new Error("Error fetching wallet: " + _context2.t0);
        case 15:
        case "end":
          return _context2.stop();
      }
    }, _callee2, null, [[0, 12]]);
  }));
  return function getWalletData(_x2) {
    return _ref3.apply(this, arguments);
  };
}();
var generateWalletForDeposit = /*#__PURE__*/function () {
  var _ref4 = /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(address) {
    var providerInfo, walletData;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          _context3.next = 2;
          return getProviderInfo({
            userAddress: address
          });
        case 2:
          providerInfo = _context3.sent;
          _context3.next = 5;
          return getWalletData(providerInfo.api_key);
        case 5:
          walletData = _context3.sent;
          return _context3.abrupt("return", walletData);
        case 7:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
  return function generateWalletForDeposit(_x3) {
    return _ref4.apply(this, arguments);
  };
}();



var index$1 = {
  __proto__: null,
  getBaseFromBase64: getBaseFromBase64,
  parseDataUrl: parseDataUrl,
  createFileFromBase64: createFileFromBase64,
  createFilesFromBase64Results: createFilesFromBase64Results,
  deleteFile: deleteFile,
  deleteFiles: deleteFiles,
  cleanupTempFiles: cleanupTempFiles,
  isBase64: isBase64,
  isDataUrl: isDataUrl,
  parseBase64Input: parseBase64Input,
  generateWalletForDeposit: generateWalletForDeposit
};

var startServer = function startServer(port, prompt, options, callback) {
  var _options;
  if (options === void 0) {
    options = {
      enableStaticServing: false,
      isStreamSupported: false,
      extendedRoutes: []
    };
  }
  var isLogger = ((_options = options) == null ? void 0 : _options.logger) || false;
  var app = express();
  if (!port) {
    throw new Error("Port is required");
  }
  if (!prompt) {
    throw new Error("Prompt function is required");
  }
  app.use(cors({
    origin: "*",
    methods: "*",
    allowedHeaders: "*",
    credentials: true
  }));
  app.use(express.json({
    limit: "50mb"
  }));
  app.use(express.urlencoded({
    extended: true
  })); // For form data
  app.options("*", cors());
  // Serve static files if enabled
  if (!!options.enableStaticServing) {
    var staticDir = options.staticDir || path.join(process.cwd(), "public");
    var staticUrlPath = options.staticUrlPath || "/";
    console.log("Serving static files from: " + staticDir + " at path: " + staticUrlPath);
    // Handle .tsx manually
    app.get("/*.tsx", /*#__PURE__*/function () {
      var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(req, res) {
        var staticDir, filePath, result;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              staticDir = options.staticDir || path.join(process.cwd(), "public");
              filePath = path.join(staticDir, req.path);
              _context.prev = 2;
              _context.next = 5;
              return esbuild.build({
                entryPoints: [filePath],
                bundle: true,
                write: false,
                platform: "browser",
                loader: {
                  ".tsx": "tsx"
                },
                format: "esm",
                target: ["esnext"],
                jsx: "automatic"
              });
            case 5:
              result = _context.sent;
              res.type("application/javascript").send(result.outputFiles[0].text);
              _context.next = 13;
              break;
            case 9:
              _context.prev = 9;
              _context.t0 = _context["catch"](2);
              console.error("TSX build error:", _context.t0);
              res.status(500).send("Error building TSX: " + _context.t0.message);
            case 13:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[2, 9]]);
      }));
      return function (_x, _x2) {
        return _ref.apply(this, arguments);
      };
    }());
    // Handle .ts manually
    app.get("/*.ts", /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(req, res) {
        var staticDir, filePath, result;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              staticDir = options.staticDir || path.join(process.cwd(), "public");
              filePath = path.join(staticDir, req.path);
              _context2.prev = 2;
              _context2.next = 5;
              return esbuild.build({
                entryPoints: [filePath],
                bundle: true,
                write: false,
                platform: "browser",
                loader: {
                  ".ts": "ts"
                },
                format: "esm",
                target: ["esnext"]
              });
            case 5:
              result = _context2.sent;
              res.type("application/javascript").send(result.outputFiles[0].text);
              _context2.next = 13;
              break;
            case 9:
              _context2.prev = 9;
              _context2.t0 = _context2["catch"](2);
              console.error("TS build error:", _context2.t0);
              res.status(500).send("Error building TS: " + _context2.t0.message);
            case 13:
            case "end":
              return _context2.stop();
          }
        }, _callee2, null, [[2, 9]]);
      }));
      return function (_x3, _x4) {
        return _ref2.apply(this, arguments);
      };
    }());
    // Serve static files, but ignore .tsx files
    // Serve static files normally
    app.use(staticUrlPath, express["static"](staticDir, {
      extensions: ["html"],
      setHeaders: function setHeaders(res, filePath) {
        // <-- FIXED TYPE HERE
        if (filePath.endsWith(".tsx")) {
          res.statusCode = 404;
        }
      }
    }));
    // Fallback for SPA routing (optional)
    if (staticUrlPath === "/" && path.join(staticDir, "index.html")) {
      app.get("*", function (req, res, next) {
        if (req.path.startsWith("/api") || req.path.startsWith("/prompt")) {
          next();
        } else {
          res.sendFile(path.join(staticDir, "index.html"));
        }
      });
    }
  }
  app.post("/prompt",
  /*#__PURE__*/
  // async (req: Request<{}, {}, RequestPromptPayload>, res: Response) => {
  function () {
    var _ref3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(req, res) {
      var payload, _options2, stream, reader, _yield$reader$read, done, value, result;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            payload = req.body;
            if (isLogger) {
              console.log("prompt: payload", payload);
            }
            _context3.prev = 2;
            if (!payload.ping) {
              _context3.next = 7;
              break;
            }
            res.send("online");
            _context3.next = 57;
            break;
          case 7:
            if (!(!!((_options2 = options) != null && _options2.isStreamSupported) && payload.stream)) {
              _context3.next = 52;
              break;
            }
            // Set headers for SSE
            res.setHeader("Content-Type", "text/event-stream");
            res.setHeader("Cache-Control", "no-cache");
            res.setHeader("Connection", "keep-alive");
            // Stream the response
            _context3.prev = 11;
            _context3.next = 14;
            return prompt(payload);
          case 14:
            stream = _context3.sent;
            if (!(stream instanceof ReadableStream)) {
              _context3.next = 40;
              break;
            }
            reader = stream.getReader();
            _context3.prev = 17;
          case 18:
            _context3.next = 21;
            return reader.read();
          case 21:
            _yield$reader$read = _context3.sent;
            done = _yield$reader$read.done;
            value = _yield$reader$read.value;
            if (!done) {
              _context3.next = 26;
              break;
            }
            return _context3.abrupt("break", 29);
          case 26:
            // Forward the chunk directly as it's already formatted as SSE
            res.write(value);
            _context3.next = 18;
            break;
          case 29:
            _context3.next = 35;
            break;
          case 31:
            _context3.prev = 31;
            _context3.t0 = _context3["catch"](17);
            console.error("Stream reading error:", _context3.t0);
            res.write("data: " + JSON.stringify({
              error: _context3.t0.message
            }) + "\n\n");
          case 35:
            _context3.prev = 35;
            res.end();
            return _context3.finish(35);
          case 38:
            _context3.next = 43;
            break;
          case 40:
            // For non-stream responses, format as SSE
            res.write("data: " + JSON.stringify(stream) + "\n\n");
            res.write("data: [DONE]\n\n");
            res.end();
          case 43:
            _context3.next = 50;
            break;
          case 45:
            _context3.prev = 45;
            _context3.t1 = _context3["catch"](11);
            console.error("Stream processing error:", _context3.t1);
            res.write("data: " + JSON.stringify({
              error: _context3.t1.message
            }) + "\n\n");
            res.end();
          case 50:
            _context3.next = 57;
            break;
          case 52:
            _context3.next = 54;
            return prompt(payload);
          case 54:
            result = _context3.sent;
            if (isLogger) {
              console.log("prompt: result", result);
            }
            res.json(result);
          case 57:
            _context3.next = 63;
            break;
          case 59:
            _context3.prev = 59;
            _context3.t2 = _context3["catch"](2);
            console.log("prompt: error", _context3.t2);
            res.status(500).json({
              error: _context3.t2.message
            });
          case 63:
          case "end":
            return _context3.stop();
        }
      }, _callee3, null, [[2, 59], [11, 45], [17, 31, 35, 38]]);
    }));
    return function (_x5, _x6) {
      return _ref3.apply(this, arguments);
    };
  }());
  // Add health check endpoint
  app.get("/health", function (_, res) {
    res.status(200).json({
      status: "ok"
    });
  });
  try {
    var _options3;
    (_options3 = options) == null || (_options3 = _options3.extendedRoutes) == null || _options3.forEach(function (route) {
      try {
        app[route.method.toLowerCase()](route.path, route.handler);
      } catch (e) {
        console.error("Error adding extended routes:", e);
      }
    });
  } catch (e) {
    console.error("Error adding extended routes:", e);
  }
  var defaultCallback = function defaultCallback(error) {
    if (error) {
      console.error("Error starting server:", error);
      return;
    }
    console.log("Server is running on http://localhost:" + port);
    if (callback) {
      callback(error);
    }
  };
  app.listen(port, defaultCallback);
  return app;
};

var listenRequest = function listenRequest() {
  axios.interceptors.request.use(function (request) {
    return request;
  }, function (error) {
    return Promise.reject(error);
  });
  var originalFetch = global.fetch;
  global.fetch = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(url, options) {
      var response;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            if (options === void 0) {
              options = {};
            }
            _context.prev = 2;
            _context.next = 5;
            return originalFetch(url, options);
          case 5:
            response = _context.sent;
            return _context.abrupt("return", response);
          case 9:
            _context.prev = 9;
            _context.t0 = _context["catch"](2);
            throw _context.t0;
          case 12:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[2, 9]]);
    }));
    return function (_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }();
};
var getHostNameFromUrl = function getHostNameFromUrl(url) {
  try {
    if (url.startsWith("http://") || url.startsWith("https://")) {
      var _urlObj = new URL(url);
      return _urlObj.hostname;
    }
    var urlObj = new URL("http://" + url);
    return urlObj.hostname;
  } catch (e) {
    try {
      var normalizedUrl = url;
      if (normalizedUrl.startsWith("http://")) {
        normalizedUrl = normalizedUrl.replace("http://", "");
      }
      if (normalizedUrl.startsWith("https://")) {
        normalizedUrl = normalizedUrl.replace("https://", "");
      }
      if (normalizedUrl.endsWith("/")) {
        normalizedUrl = normalizedUrl.slice(0, -1);
      }
      return normalizedUrl.split("/")[0];
    } catch (e) {
      //
    }
  }
  return url;
};
var setupRequestMiddleware = function setupRequestMiddleware(_ref2) {
  var from = _ref2.from,
    to = _ref2.to,
    privateKey = _ref2.privateKey,
    chainId = _ref2.chainId;
  listenRequest();
  // normalized data
  var fromDomain = from instanceof Array ? from.map(function (item) {
    return item.trim();
  }).filter(function (item) {
    return !!item;
  }) : ("" + from).trim();
  if (typeof fromDomain === "string" && fromDomain !== "*") {
    fromDomain = getHostNameFromUrl(fromDomain);
  } else if (typeof fromDomain === "object") {
    fromDomain = fromDomain.map(function (item) {
      return getHostNameFromUrl(item);
    });
  }
  var toDomain = ("" + to).trim();
  if (!!fromDomain && !!toDomain) {
    // Store the original create function and default adapter
    var originalCreate = axios.create;
    var getRewriteUrl = function getRewriteUrl() {
      return toDomain;
    };
    var compareUrls = function compareUrls(fromUrl, toUrl) {
      var isEqual = fromUrl.toLowerCase() === toUrl.toLowerCase();
      // console.log(
      //   "_____compareUrls_____",
      //   fromUrl,
      //   toUrl,
      //   fromUrlObj,
      //   toUrlObj,
      //   isEqual
      // );
      return isEqual;
    };
    var checkDomainCondition = function checkDomainCondition(requestDomain) {
      try {
        // console.log("_____checkDomainCondition_____", requestDomain);
        if (fromDomain instanceof Array) {
          if (fromDomain.find(function (item) {
            return compareUrls(item, requestDomain);
          })) {
            return true;
          }
        } else {
          if (fromDomain === "*") {
            var normalizedToDomain = getHostNameFromUrl(toDomain);
            if (!compareUrls(requestDomain, normalizedToDomain)) {
              return true;
            }
          } else {
            if (compareUrls(requestDomain, fromDomain)) {
              return true;
            }
          }
        }
        return false;
      } catch (e) {
        return false;
      }
    };
    // Override axios.create
    axios.create = function createWithMiddleware(config) {
      if (config === void 0) {
        config = {};
      }
      var instance = originalCreate(config);
      instance.interceptors.request.use(function (config) {
        try {
          var originalConfig = config;
          if (config.url) {
            // Handle both absolute and relative URLs
            var fullUrl = config.url.startsWith("http") ? new URL(config.url) : new URL(config.url, config.baseURL || undefined);
            var originalUrl = fullUrl.toString();
            if (checkDomainCondition(fullUrl.hostname)) {
              console.log("_____overwrite request url_____", fullUrl.href, toDomain);
              fullUrl.hostname = toDomain;
              config.url = getRewriteUrl();
              config.method = "POST";
              config.data = JSON.parse(JSON.stringify({
                privateKey: privateKey,
                chainId: chainId,
                messages: [{
                  role: "user",
                  content: JSON.stringify({
                    url: originalUrl,
                    method: originalConfig.method || "GET",
                    body: originalConfig.data,
                    headers: originalConfig.headers
                  })
                }]
              }));
            }
          }
        } catch (error) {
          console.error("Error processing axios request:", error);
        }
        return config;
      }, function (error) {
        return Promise.reject(error);
      });
      return instance;
    };
    // Intercept axios requests
    axios.interceptors.request.use(function (config) {
      try {
        var originalConfig = config;
        if (config.url) {
          // Handle both absolute and relative URLs
          var fullUrl = config.url.startsWith("http") ? new URL(config.url) : new URL(config.url, config.baseURL || undefined);
          var originalUrl = fullUrl.toString();
          if (checkDomainCondition(fullUrl.hostname)) {
            console.log("_____overwrite request url_____", fullUrl.href, toDomain);
            fullUrl.hostname = toDomain;
            config.url = getRewriteUrl();
            config.method = "POST";
            config.data = JSON.parse(JSON.stringify({
              privateKey: privateKey,
              chainId: chainId,
              messages: [{
                role: "user",
                content: JSON.stringify({
                  url: originalUrl,
                  method: originalConfig.method || "GET",
                  body: originalConfig.data,
                  headers: originalConfig.headers
                })
              }]
            }));
          }
        }
      } catch (error) {
        console.error("Error processing axios request:", error);
      }
      return config;
    }, function (error) {
      return Promise.reject(error);
    });
    // Intercept fetch if available
    var originalFetch = global.fetch;
    if (typeof originalFetch === "function") {
      global.fetch = /*#__PURE__*/function () {
        var _ref3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(input, init) {
          var url, urlObj, payload, result;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                _context2.prev = 0;
                url = typeof input === "string" ? input : input instanceof URL ? input.toString() : input.url;
                urlObj = new URL(url);
                if (!checkDomainCondition(urlObj.hostname)) {
                  _context2.next = 11;
                  break;
                }
                console.log("_____overwrite request url_____", urlObj.href, toDomain);
                payload = {};
                urlObj.hostname = toDomain;
                payload = {
                  privateKey: privateKey,
                  chainId: chainId,
                  messages: [{
                    role: "user",
                    content: JSON.stringify({
                      url: url,
                      method: (init == null ? void 0 : init.method) || "GET",
                      body: init == null ? void 0 : init.body,
                      headers: init == null ? void 0 : init.headers,
                      search: urlObj.searchParams
                    })
                  }]
                };
                if (typeof input === "string") {
                  input = urlObj.toString();
                  payload.url = input;
                } else if (input instanceof URL) {
                  input = urlObj;
                  payload.url = input;
                } else {
                  input = new Request(urlObj, input);
                  payload.url = input.url;
                }
                result = originalFetch(getRewriteUrl(), {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json"
                  },
                  body: JSON.stringify(payload)
                });
                return _context2.abrupt("return", result);
              case 11:
                _context2.next = 16;
                break;
              case 13:
                _context2.prev = 13;
                _context2.t0 = _context2["catch"](0);
                console.error("Error processing fetch request:", _context2.t0);
              case 16:
                return _context2.abrupt("return", originalFetch(input, init));
              case 17:
              case "end":
                return _context2.stop();
            }
          }, _callee2, null, [[0, 13]]);
        }));
        return function (_x3, _x4) {
          return _ref3.apply(this, arguments);
        };
      }();
    }
    if (fromDomain instanceof Array) {
      console.log("Request interceptor active: redirecting " + fromDomain.join(",") + " \u2192 " + toDomain);
    } else {
      if (fromDomain === "*") {
        console.log("Request interceptor active: redirecting all domain \u2192 " + toDomain);
      } else {
        console.log("Request interceptor active: redirecting " + fromDomain + " \u2192 " + toDomain);
      }
    }
  }
};

export { index as constants, setupRequestMiddleware, startServer, index$1 as utils };
//# sourceMappingURL=agent-server-definition.esm.js.map
