{"version":3,"file":"agent-server-definition.cjs.production.min.js","sources":["../src/utils/file.ts","../src/constants/host.ts","../src/constants/port.ts","../src/utils/wallet.ts","../src/request-middleware.ts","../src/server/index.ts"],"sourcesContent":["import fs from \"fs\";\nimport path from \"path\";\nimport { Base64Result, Message } from \"../types\";\n\nexport const getBaseFromBase64 = (\n  type: string,\n  messages: Message[]\n): Base64Result[] => {\n  const result: Base64Result[] = [];\n  messages.forEach(message => {\n    if (Array.isArray(message.content)) {\n      message.content.forEach(contentItem => {\n        if (contentItem.type === type) {\n          const [contentType, base64] = contentItem[type].url.split(\",\");\n          result.push({\n            type: contentType.split(\":\")[1].split(\";\")[0],\n            base64: base64,\n            fileName: contentItem[type].detail\n          });\n        }\n      });\n    }\n  });\n  return result;\n};\n\n/**\n * Detect file type from binary data using magic numbers\n * @param buffer - Buffer containing the file data\n * @returns File type info {mime: string, ext: string} or null if unknown\n */\n/**\n * Detect file type from binary data or MIME type string\n * @param input - Either a Buffer containing file data or a MIME type string\n * @returns File type info {mime: string, ext: string} or null if unknown\n */\nconst detectFileType = (mime: string): string | null => {\n  // If input is a string, assume it's a MIME type\n  const mimeType = mime.toLowerCase().trim();\n\n  // Common MIME types to extension mapping\n  const mimeMapping: Record<string, string> = {\n    \"image/png\": \"png\",\n    \"image/jpeg\": \"jpg\",\n    \"image/jpg\": \"jpg\",\n    \"image/gif\": \"gif\",\n    \"image/webp\": \"webp\",\n    \"image/svg+xml\": \"svg\",\n    \"application/pdf\": \"pdf\",\n    \"audio/mpeg\": \"mp3\",\n    \"audio/mp3\": \"mp3\",\n    \"video/mp4\": \"mp4\",\n    \"video/mpeg\": \"mpg\",\n    \"application/json\": \"json\",\n    \"text/plain\": \"txt\",\n    \"text/html\": \"html\",\n    \"text/css\": \"css\",\n    \"text/javascript\": \"js\",\n    \"application/javascript\": \"js\",\n    \"application/xml\": \"xml\",\n    \"text/xml\": \"xml\",\n    \"application/zip\": \"zip\",\n    \"application/x-zip-compressed\": \"zip\",\n    \"application/msword\": \"doc\",\n    \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\":\n      \"docx\",\n    \"application/vnd.ms-excel\": \"xls\",\n    \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\": \"xlsx\",\n    \"application/vnd.ms-powerpoint\": \"ppt\",\n    \"application/vnd.openxmlformats-officedocument.presentationml.presentation\":\n      \"pptx\"\n  };\n\n  // Return known extension or extract from MIME type\n  if (mimeMapping[mimeType]) {\n    return mimeMapping[mimeType];\n  }\n\n  return null;\n};\n\nexport const parseDataUrl = (\n  dataUrl: string\n): { mimeType: string; base64: string; buffer: Buffer } | null => {\n  if (!dataUrl || typeof dataUrl !== \"string\") {\n    return null;\n  }\n\n  // Check if this is a valid data URL format\n  const dataUrlRegex = /^data:([^;,]+)(;base64)?,(.*)/;\n  const matches = dataUrl.match(dataUrlRegex);\n\n  if (!matches || matches.length < 4) {\n    return null;\n  }\n\n  return {\n    mimeType: matches[1],\n    base64: matches[3],\n    buffer: Buffer.from(matches[3], \"base64\")\n  };\n};\n\n/**\n * Creates a file from base64 data\n * @param base64 - The base64 string (without the data:image/png;base64, prefix)\n * @param fileName - Name for the created file\n * @param directory - Directory to store the file (default: 'tmp')\n * @param fileType - Optional MIME type (e.g., 'image/png')\n * @returns Promise with the full path to the created file\n */\nexport const createFileFromBase64 = async (\n  base64: string,\n  fileName: string,\n  directory: string = \"tmp\"\n): Promise<string> => {\n  // Create directory if it doesn't exist\n  await fs.promises.mkdir(directory, { recursive: true });\n\n  // Convert base64 to buffer\n  // const buffer = Buffer.from(base64, \"base64\");\n\n  const data = parseDataUrl(base64);\n  if (!data) {\n    throw new Error(\"Invalid base64 data\");\n  }\n  const { mimeType, buffer } = data;\n  // Auto-detect file type from buffer\n  const extension = mimeType ? detectFileType(mimeType) : \"\";\n\n  // Create a safe filename if not provided\n  let safeFileName =\n    fileName ||\n    `file-${Date.now()}-${Math.random()\n      .toString(36)\n      .substring(2, 10)}`;\n\n  // Add extension if not present in the filename\n  if (path.extname(safeFileName) === \"\") {\n    safeFileName = `${safeFileName}.${extension}`;\n  }\n\n  // Generate file path\n  const filePath = path.join(directory, safeFileName);\n\n  // Write buffer to file\n  await fs.promises.writeFile(filePath, buffer);\n\n  // Return the full path\n  return filePath;\n};\n\n/**\n * Creates files from the results of getBaseFromBase64\n * @param results - Array of Base64Result objects\n * @param directory - Directory to store the files (default: 'tmp')\n * @returns Promise with array of file paths\n */\nexport const createFilesFromBase64Results = async (\n  results: Base64Result[],\n  directory: string = \"tmp\"\n): Promise<string[]> => {\n  const filePaths: string[] = [];\n\n  for (const result of results) {\n    // Pass file type to createFileFromBase64\n    const filePath = await createFileFromBase64(\n      result.base64,\n      result.fileName ||\n        `file-${Date.now()}-${Math.random()\n          .toString(36)\n          .substring(2, 10)}`,\n      directory\n    );\n    filePaths.push(filePath);\n  }\n\n  return filePaths;\n};\n\n/**\n * Deletes a file if it exists\n * @param filePath - Path to the file to delete\n * @returns Promise<boolean> - True if file was deleted, false if file didn't exist\n */\nexport const deleteFile = async (filePath: string): Promise<boolean> => {\n  try {\n    // Check if file exists\n    await fs.promises.access(filePath);\n\n    // Delete the file\n    await fs.promises.unlink(filePath);\n    return true;\n  } catch (error) {\n    // File doesn't exist or other error\n    if ((error as any).code === \"ENOENT\") {\n      return false;\n    }\n    // Re-throw unexpected errors\n    throw error;\n  }\n};\n\n/**\n * Deletes multiple files\n * @param filePaths - Array of file paths to delete\n * @returns Promise<{deleted: string[], notFound: string[], failed: {path: string, error: string}[]}>\n */\nexport const deleteFiles = async (\n  filePaths: string[]\n): Promise<{\n  deleted: string[];\n  notFound: string[];\n  failed: Array<{ path: string; error: string }>;\n}> => {\n  const results = {\n    deleted: [] as string[],\n    notFound: [] as string[],\n    failed: [] as Array<{ path: string; error: string }>\n  };\n\n  await Promise.all(\n    filePaths.map(async filePath => {\n      try {\n        const deleted = await deleteFile(filePath);\n        if (deleted) {\n          results.deleted.push(filePath);\n        } else {\n          results.notFound.push(filePath);\n        }\n      } catch (error) {\n        results.failed.push({\n          path: filePath,\n          error: (error as any).message || String(error)\n        });\n      }\n    })\n  );\n\n  return results;\n};\n\n/**\n * Cleans up temporary files in a directory\n * @param directory - Directory to clean\n * @param maxAge - Maximum age of files to keep (in milliseconds)\n * @returns Promise with deletion results\n */\nexport const cleanupTempFiles = async (\n  directory: string = \"tmp\",\n  maxAge: number = 24 * 60 * 60 * 1000 // Default: 24 hours\n): Promise<{\n  deleted: string[];\n  notFound: string[];\n  failed: Array<{ path: string; error: string }>;\n}> => {\n  try {\n    // Check if directory exists\n    await fs.promises.access(directory);\n\n    // Get all files in directory\n    const files = await fs.promises.readdir(directory);\n    const now = Date.now();\n    const filesToDelete: string[] = [];\n\n    // Check each file's age\n    for (const file of files) {\n      const filePath = path.join(directory, file);\n      try {\n        const stats = await fs.promises.stat(filePath);\n        const fileAge = now - stats.mtimeMs;\n\n        if (fileAge > maxAge) {\n          filesToDelete.push(filePath);\n        }\n      } catch (error) {\n        console.error(`Error checking file ${filePath}:`, error);\n      }\n    }\n\n    // Delete old files\n    return await deleteFiles(filesToDelete);\n  } catch (error) {\n    if ((error as any).code === \"ENOENT\") {\n      return { deleted: [], notFound: [], failed: [] };\n    }\n    throw error;\n  }\n};\n\n/**\n * Checks if a string is base64 encoded\n * @param str - The string to check\n * @param strict - Whether to perform strict validation (including decoding test)\n * @returns boolean - True if the string is base64 encoded, false otherwise\n */\nexport const isBase64 = (str: string, strict: boolean = false): boolean => {\n  if (!str || typeof str !== \"string\") {\n    return false;\n  }\n\n  // Check 1: String only contains valid base64 characters\n  const base64Regex = /^[A-Za-z0-9+/]*={0,2}$/;\n  if (!base64Regex.test(str)) {\n    return false;\n  }\n\n  // Check 2: Length is valid (multiple of 4)\n  if (str.length % 4 !== 0) {\n    return false;\n  }\n\n  // Check 3: Padding (=) only appears at the end and at most 2\n  const paddingMatch = str.match(/=*$/);\n  if (paddingMatch && paddingMatch[0].length > 2) {\n    return false;\n  }\n\n  // Check 4: If strict mode, try to decode it\n  if (strict) {\n    try {\n      Buffer.from(str, \"base64\").toString();\n      return true;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Checks if a string is a data URL\n * @param str - The string to check\n * @returns boolean - True if the string is a data URL, false otherwise\n */\nexport const isDataUrl = (str: string): boolean => {\n  if (!str || typeof str !== \"string\") {\n    return false;\n  }\n\n  const dataUrlRegex = /^data:([^;,]+)(;base64)?,/;\n  return dataUrlRegex.test(str);\n};\n\n/**\n * Detects if a string is base64 or data URL and extracts base64 content\n * @param input - The string to check (could be base64 encoded string or data URL)\n * @returns Object with type and content, or null if not recognized\n */\nexport const parseBase64Input = (\n  input: string\n): {\n  type: \"base64\" | \"dataUrl\";\n  content: string;\n  mimeType?: string;\n} | null => {\n  if (!input || typeof input !== \"string\") {\n    return null;\n  }\n\n  // Check if it's a data URL\n  if (isDataUrl(input)) {\n    const parsed = parseDataUrl(input);\n    if (!parsed) return null;\n\n    return {\n      type: \"dataUrl\",\n      content: parsed.base64,\n      mimeType: parsed.mimeType\n    };\n  }\n\n  // Check if it's a plain base64 string\n  if (isBase64(input)) {\n    return {\n      type: \"base64\",\n      content: input\n    };\n  }\n\n  return null;\n};\n","export const API_PROVIDER_URL = \"https://agent-service.eternalai.org/api/v1\";\n","export const PORT_LOCAL_MODEL = 65534;\nexport const PORT_AGENT_ROUTER = 33030;\nexport const PORT_AGENT_PROMPT_BASE = 80;\nexport const PORT_AGENT_STANDALONE = 8080;\n","import { API_PROVIDER_URL } from \"../constants\";\nimport { ProviderInfo, WalletData } from \"../types\";\n\nconst getProviderInfo = async ({\n  userAddress\n}: {\n  userAddress: string;\n}): Promise<ProviderInfo> => {\n  try {\n    const response = await fetch(`${API_PROVIDER_URL}/agent/wallet`, {\n      method: \"POST\",\n      body: JSON.stringify({ user_address: userAddress }),\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    });\n\n    if (!response.ok) {\n      throw new Error(`Error fetching wallet: ${response.statusText}`);\n    }\n    const responseBody = await response.json();\n    return responseBody.data;\n  } catch (error) {\n    throw new Error(`Error fetching wallet: ${error}`);\n  }\n};\n\nconst getWalletData = async (apiKey: string): Promise<WalletData> => {\n  try {\n    const response = await fetch(`${API_PROVIDER_URL}/agent/wallet/${apiKey}`, {\n      method: \"GET\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    });\n\n    if (!response.ok) {\n      throw new Error(`Error fetching wallet: ${response.statusText}`);\n    }\n    const responseBody = await response.json();\n    return responseBody.data;\n  } catch (error) {\n    throw new Error(`Error fetching wallet: ${error}`);\n  }\n};\n\nexport const generateWalletForDeposit = async (address: string) => {\n  const providerInfo = await getProviderInfo({\n    userAddress: address\n  });\n\n  const walletData = await getWalletData(providerInfo.api_key);\n  return walletData;\n};\n","import axios from \"axios\";\nimport { URL } from \"url\";\n\nconst listenRequest = () => {\n  const logRequestUrl = (url: string | undefined | RequestInfo | URL) => {\n    if (url) {\n      // console.log(\"_____Request URL:_____\", url);\n    }\n  };\n  axios.interceptors.request.use(\n    request => {\n      logRequestUrl(request.url);\n      return request;\n    },\n    error => {\n      return Promise.reject(error);\n    }\n  );\n\n  const originalFetch = global.fetch;\n  global.fetch = async (url, options = {}) => {\n    logRequestUrl(url);\n\n    try {\n      const response = await originalFetch(url, options);\n      return response;\n    } catch (error) {\n      throw error;\n    }\n  };\n};\n\nconst getHostNameFromUrl = (url: string) => {\n  try {\n    if (url.startsWith(\"http://\") || url.startsWith(\"https://\")) {\n      const urlObj = new URL(url);\n      return urlObj.hostname;\n    }\n    const urlObj = new URL(`http://${url}`);\n    return urlObj.hostname;\n  } catch (e) {\n    try {\n      let normalizedUrl = url;\n      if (normalizedUrl.startsWith(\"http://\")) {\n        normalizedUrl = normalizedUrl.replace(\"http://\", \"\");\n      }\n      if (normalizedUrl.startsWith(\"https://\")) {\n        normalizedUrl = normalizedUrl.replace(\"https://\", \"\");\n      }\n      if (normalizedUrl.endsWith(\"/\")) {\n        normalizedUrl = normalizedUrl.slice(0, -1);\n      }\n      return normalizedUrl.split(\"/\")[0];\n    } catch (e) {\n      //\n    }\n  }\n  return url;\n};\n\nexport const setupRequestMiddleware = ({\n  from,\n  to,\n  privateKey,\n  chainId\n}: {\n  from: string | \"*\" | string[];\n  to: string;\n  privateKey: string;\n  chainId: string;\n}) => {\n  listenRequest();\n\n  // normalized data\n  let fromDomain =\n    from instanceof Array\n      ? from.map(item => item.trim()).filter(item => !!item)\n      : `${from}`.trim();\n\n  if (typeof fromDomain === \"string\" && fromDomain !== \"*\") {\n    fromDomain = getHostNameFromUrl(fromDomain);\n  } else if (typeof fromDomain === \"object\") {\n    fromDomain = fromDomain.map(item => {\n      return getHostNameFromUrl(item);\n    });\n  }\n\n  let toDomain = `${to}`.trim();\n\n  if (!!fromDomain && !!toDomain) {\n    // Store the original create function and default adapter\n    const originalCreate = axios.create;\n\n    const getRewriteUrl = () => {\n      return toDomain;\n    };\n\n    const compareUrls = (fromUrl: string, toUrl: string) => {\n      const isEqual = fromUrl.toLowerCase() === toUrl.toLowerCase();\n      // console.log(\n      //   \"_____compareUrls_____\",\n      //   fromUrl,\n      //   toUrl,\n      //   fromUrlObj,\n      //   toUrlObj,\n      //   isEqual\n      // );\n      return isEqual;\n    };\n\n    const checkDomainCondition = (requestDomain: string) => {\n      try {\n        // console.log(\"_____checkDomainCondition_____\", requestDomain);\n        if (fromDomain instanceof Array) {\n          if (fromDomain.find(item => compareUrls(item, requestDomain))) {\n            return true;\n          }\n        } else {\n          if (fromDomain === \"*\") {\n            let normalizedToDomain = getHostNameFromUrl(toDomain);\n            if (!compareUrls(requestDomain, normalizedToDomain)) {\n              return true;\n            }\n          } else {\n            if (compareUrls(requestDomain, fromDomain)) {\n              return true;\n            }\n          }\n        }\n        return false;\n      } catch (e) {\n        return false;\n      }\n    };\n\n    // Override axios.create\n    axios.create = function createWithMiddleware(config = {}) {\n      const instance = originalCreate(config);\n\n      instance.interceptors.request.use(\n        config => {\n          try {\n            const originalConfig = config;\n            if (config.url) {\n              // Handle both absolute and relative URLs\n              const fullUrl = config.url.startsWith(\"http\")\n                ? new URL(config.url)\n                : new URL(config.url, config.baseURL || undefined);\n\n              const originalUrl = fullUrl.toString();\n              if (checkDomainCondition(fullUrl.hostname)) {\n                console.log(\n                  \"_____overwrite request url_____\",\n                  fullUrl.href,\n                  toDomain\n                );\n                fullUrl.hostname = toDomain;\n                config.url = getRewriteUrl();\n                config.method = \"POST\";\n                config.data = JSON.parse(\n                  JSON.stringify({\n                    privateKey,\n                    chainId,\n                    messages: [\n                      {\n                        role: \"user\",\n                        content: JSON.stringify({\n                          url: originalUrl,\n                          method: originalConfig.method || \"GET\",\n                          body: originalConfig.data,\n                          headers: originalConfig.headers\n                        })\n                      }\n                    ]\n                  })\n                );\n              }\n            }\n          } catch (error) {\n            console.error(\"Error processing axios request:\", error);\n          }\n          return config;\n        },\n        error => Promise.reject(error)\n      );\n\n      return instance;\n    };\n\n    // Intercept axios requests\n    axios.interceptors.request.use(\n      config => {\n        try {\n          const originalConfig = config;\n          if (config.url) {\n            // Handle both absolute and relative URLs\n            const fullUrl = config.url.startsWith(\"http\")\n              ? new URL(config.url)\n              : new URL(config.url, config.baseURL || undefined);\n\n            const originalUrl = fullUrl.toString();\n\n            if (checkDomainCondition(fullUrl.hostname)) {\n              console.log(\n                \"_____overwrite request url_____\",\n                fullUrl.href,\n                toDomain\n              );\n              fullUrl.hostname = toDomain;\n              config.url = getRewriteUrl();\n              config.method = \"POST\";\n              config.data = JSON.parse(\n                JSON.stringify({\n                  privateKey,\n                  chainId,\n                  messages: [\n                    {\n                      role: \"user\",\n                      content: JSON.stringify({\n                        url: originalUrl,\n                        method: originalConfig.method || \"GET\",\n                        body: originalConfig.data,\n                        headers: originalConfig.headers\n                      })\n                    }\n                  ]\n                })\n              );\n            }\n          }\n        } catch (error) {\n          console.error(\"Error processing axios request:\", error);\n        }\n        return config;\n      },\n      error => Promise.reject(error)\n    );\n\n    // Intercept fetch if available\n    const originalFetch = global.fetch;\n    if (typeof originalFetch === \"function\") {\n      global.fetch = async function(\n        input: RequestInfo | URL,\n        init?: RequestInit\n      ): Promise<Response> {\n        try {\n          let url =\n            typeof input === \"string\"\n              ? input\n              : input instanceof URL\n              ? input.toString()\n              : input.url;\n          const urlObj = new URL(url);\n          if (checkDomainCondition(urlObj.hostname)) {\n            console.log(\n              \"_____overwrite request url_____\",\n              urlObj.href,\n              toDomain\n            );\n            let payload: Record<string, any> = {};\n            urlObj.hostname = toDomain;\n\n            payload = {\n              privateKey,\n              chainId,\n              messages: [\n                {\n                  role: \"user\",\n                  content: JSON.stringify({\n                    url: url,\n                    method: init?.method || \"GET\",\n                    body: init?.body,\n                    headers: init?.headers,\n                    search: urlObj.searchParams\n                  })\n                }\n              ]\n            };\n\n            if (typeof input === \"string\") {\n              input = urlObj.toString();\n              payload.url = input;\n            } else if (input instanceof URL) {\n              input = urlObj;\n              payload.url = input;\n            } else {\n              input = new Request(urlObj as any, input);\n              payload.url = input.url;\n            }\n\n            const result = originalFetch(getRewriteUrl(), {\n              method: \"POST\", // Use POST method.\n              headers: {\n                \"Content-Type\": \"application/json\"\n              },\n              body: JSON.stringify(payload)\n            });\n            return result;\n          }\n        } catch (error) {\n          console.error(\"Error processing fetch request:\", error);\n        }\n        return originalFetch(input as any, init);\n      };\n    }\n\n    if (fromDomain instanceof Array) {\n      console.log(\n        `Request interceptor active: redirecting ${fromDomain.join(\n          \",\"\n        )} → ${toDomain}`\n      );\n    } else {\n      if (fromDomain === \"*\") {\n        console.log(\n          `Request interceptor active: redirecting all domain → ${toDomain}`\n        );\n      } else {\n        console.log(\n          `Request interceptor active: redirecting ${fromDomain} → ${toDomain}`\n        );\n      }\n    }\n  }\n};\n\nexport default setupRequestMiddleware;\n","// import express, { Request, Response } from \"express\";\nimport express, { Express } from \"express\";\nimport cors from \"cors\";\nimport path from \"path\";\nimport esbuild from \"esbuild\";\nimport { PromptFunction, RequestPromptPayload } from \"../types\";\nimport { Request, Response } from \"express\";\n\ninterface ServerOptions {\n  staticDir?: string;\n  staticUrlPath?: string;\n  enableStaticServing?: boolean;\n  logger?: boolean; // default is false\n  isStreamSupported?: boolean;\n\n  extendedRoutes?: {\n    path: string;\n    method: \"GET\" | \"POST\" | \"PUT\" | \"DELETE\";\n    handler: (req: Request, res: Response) => void;\n  }[];\n}\nexport const startServer = (\n         port: number,\n         prompt: PromptFunction,\n         options: ServerOptions = {\n           enableStaticServing: false,\n           isStreamSupported: false,\n           extendedRoutes: []\n         },\n         callback?: (error?: Error) => void\n       ): Express => {\n         const isLogger = options?.logger || false;\n         const app = express();\n\n         if (!port) {\n           throw new Error(\"Port is required\");\n         }\n\n         if (!prompt) {\n           throw new Error(\"Prompt function is required\");\n         }\n\n         app.use(\n           cors({\n             origin: \"*\",\n             methods: \"*\",\n             allowedHeaders: \"*\",\n             credentials: true\n           })\n         );\n         app.use(express.json({ limit: \"50mb\" }));\n         app.use(express.urlencoded({ extended: true })); // For form data\n         app.options(\"*\", cors());\n\n         // Serve static files if enabled\n         if (!!options.enableStaticServing) {\n           const staticDir =\n             options.staticDir || path.join(process.cwd(), \"public\");\n           const staticUrlPath = options.staticUrlPath || \"/\";\n\n           console.log(\n             `Serving static files from: ${staticDir} at path: ${staticUrlPath}`\n           );\n\n           // Handle .tsx manually\n           app.get(\"/*.tsx\", async (req, res) => {\n             const staticDir =\n               options.staticDir || path.join(process.cwd(), \"public\");\n             const filePath = path.join(staticDir, req.path);\n\n             try {\n               const result = await esbuild.build({\n                 entryPoints: [filePath],\n                 bundle: true,\n                 write: false,\n                 platform: \"browser\",\n                 loader: { \".tsx\": \"tsx\" },\n                 format: \"esm\",\n                 target: [\"esnext\"],\n                 jsx: \"automatic\"\n               });\n\n               res\n                 .type(\"application/javascript\")\n                 .send(result.outputFiles[0].text);\n             } catch (err) {\n               console.error(`TSX build error:`, err);\n               res\n                 .status(500)\n                 .send(`Error building TSX: ${(err as any).message}`);\n             }\n           });\n\n           // Handle .ts manually\n           app.get(\"/*.ts\", async (req, res) => {\n             const staticDir =\n               options.staticDir || path.join(process.cwd(), \"public\");\n             const filePath = path.join(staticDir, req.path);\n\n             try {\n               const result = await esbuild.build({\n                 entryPoints: [filePath],\n                 bundle: true,\n                 write: false,\n                 platform: \"browser\",\n                 loader: { \".ts\": \"ts\" },\n                 format: \"esm\",\n                 target: [\"esnext\"]\n               });\n\n               res\n                 .type(\"application/javascript\")\n                 .send(result.outputFiles[0].text);\n             } catch (err) {\n               console.error(`TS build error:`, err);\n               res\n                 .status(500)\n                 .send(`Error building TS: ${(err as any).message}`);\n             }\n           });\n\n           // Serve static files, but ignore .tsx files\n           // Serve static files normally\n           app.use(\n             staticUrlPath,\n             express.static(staticDir, {\n               extensions: [\"html\"],\n               setHeaders: (res: any, filePath) => {\n                 // <-- FIXED TYPE HERE\n                 if (filePath.endsWith(\".tsx\")) {\n                   res.statusCode = 404;\n                 }\n               }\n             })\n           );\n\n           // Fallback for SPA routing (optional)\n           if (staticUrlPath === \"/\" && path.join(staticDir, \"index.html\")) {\n             app.get(\"*\", (req, res, next) => {\n               if (\n                 req.path.startsWith(\"/api\") ||\n                 req.path.startsWith(\"/prompt\")\n               ) {\n                 next();\n               } else {\n                 res.sendFile(path.join(staticDir, \"index.html\"));\n               }\n             });\n           }\n         }\n\n         app.post(\n           \"/prompt\",\n           // async (req: Request<{}, {}, RequestPromptPayload>, res: Response) => {\n           async (req: any, res: any) => {\n             const payload: RequestPromptPayload = req.body;\n             if (isLogger) {\n               console.log(\"prompt: payload\", payload);\n             }\n             try {\n               if (!!payload.ping) {\n                 res.send(\"online\");\n               } else {\n                 if (!!options?.isStreamSupported && payload.stream) {\n                   // Set headers for SSE\n                   res.setHeader(\"Content-Type\", \"text/event-stream\");\n                   res.setHeader(\"Cache-Control\", \"no-cache\");\n                   res.setHeader(\"Connection\", \"keep-alive\");\n\n                   // Stream the response\n                   try {\n                     const stream = await prompt(payload);\n                     if (stream instanceof ReadableStream) {\n                       const reader = stream.getReader();\n\n                       try {\n                         while (true) {\n                           const { done, value } = await reader.read();\n                           if (done) {\n                             break;\n                           }\n                           // Forward the chunk directly as it's already formatted as SSE\n                           res.write(value);\n                         }\n                       } catch (error) {\n                         console.error(\"Stream reading error:\", error);\n                         res.write(\n                           `data: ${JSON.stringify({\n                             error: (error as Error).message\n                           })}\\n\\n`\n                         );\n                       } finally {\n                         res.end();\n                       }\n                     } else {\n                       // For non-stream responses, format as SSE\n                       res.write(`data: ${JSON.stringify(stream)}\\n\\n`);\n                       res.write(\"data: [DONE]\\n\\n\");\n                       res.end();\n                     }\n                   } catch (error) {\n                     console.error(\"Stream processing error:\", error);\n                     res.write(\n                       `data: ${JSON.stringify({\n                         error: (error as Error).message\n                       })}\\n\\n`\n                     );\n                     res.end();\n                   }\n                 } else {\n                   // Non-streaming response\n                   const result = await prompt(payload);\n                   if (isLogger) {\n                     console.log(\"prompt: result\", result);\n                   }\n                   res.json(result);\n                 }\n               }\n             } catch (error) {\n               console.log(\"prompt: error\", error);\n               res.status(500).json({ error: (error as Error).message });\n             }\n           }\n         );\n\n         // Add health check endpoint\n         app.get(\"/health\", (_: any, res: any) => {\n           res.status(200).json({ status: \"ok\" });\n         });\n\n         try {\n           options?.extendedRoutes?.forEach(route => {\n             try {\n               app[route.method.toLowerCase()](route.path, route.handler);\n             } catch (e) {\n               console.error(\"Error adding extended routes:\", e);\n             }\n           });\n         } catch (e) {\n           console.error(\"Error adding extended routes:\", e);\n         }\n\n         const defaultCallback = (error?: Error) => {\n           if (error) {\n             console.error(`Error starting server:`, error);\n             return;\n           }\n           console.log(`Server is running on http://localhost:${port}`);\n           if (callback) {\n             callback(error);\n           }\n         };\n\n         app.listen(port, defaultCallback);\n         return app;\n       };\n"],"names":["detectFileType","mime","mimeType","toLowerCase","trim","mimeMapping","image/png","image/jpeg","image/jpg","image/gif","image/webp","image/svg+xml","application/pdf","audio/mpeg","audio/mp3","video/mp4","video/mpeg","application/json","text/plain","text/html","text/css","text/javascript","application/javascript","application/xml","text/xml","application/zip","application/x-zip-compressed","application/msword","application/vnd.openxmlformats-officedocument.wordprocessingml.document","application/vnd.ms-excel","application/vnd.openxmlformats-officedocument.spreadsheetml.sheet","application/vnd.ms-powerpoint","application/vnd.openxmlformats-officedocument.presentationml.presentation","parseDataUrl","dataUrl","matches","match","length","base64","buffer","Buffer","from","createFileFromBase64","_ref","_asyncToGenerator","_regeneratorRuntime","mark","_callee","fileName","directory","_context","next","fs","promises","mkdir","recursive","data","Error","extension","safeFileName","Date","now","Math","random","toString","substring","path","extname","filePath","join","writeFile","abrupt","stop","_x","_x2","_x3","apply","arguments","createFilesFromBase64Results","_ref2","_callee2","results","filePaths","_iterator","_createForOfIteratorHelperLoose","_step","done","_context2","result","value","push","sent","_x4","_x5","deleteFile","_ref3","_callee3","wrap","_context3","prev","access","unlink","t0","code","_x6","deleteFiles","_ref4","_callee5","_context5","deleted","notFound","failed","Promise","all","map","_ref5","_callee4","_context4","error","message","String","_x8","_x7","cleanupTempFiles","_ref6","_callee6","maxAge","files","filesToDelete","_iterator2","_step2","_context6","readdir","stat","mtimeMs","console","t1","_x9","_x10","isBase64","str","strict","test","paddingMatch","isDataUrl","API_PROVIDER_URL","getProviderInfo","userAddress","response","fetch","method","body","JSON","stringify","user_address","headers","Content-Type","ok","statusText","json","getWalletData","apiKey","type","messages","forEach","Array","isArray","content","contentItem","_contentItem$type$url","url","split","detail","input","parsed","address","providerInfo","api_key","getHostNameFromUrl","startsWith","URL","hostname","e","normalizedUrl","replace","endsWith","slice","to","privateKey","chainId","axios","interceptors","request","use","reject","originalFetch","global","options","listenRequest","fromDomain","item","filter","toDomain","originalCreate","create","getRewriteUrl","compareUrls","fromUrl","toUrl","checkDomainCondition","requestDomain","find","normalizedToDomain","config","instance","originalConfig","fullUrl","baseURL","undefined","originalUrl","log","href","parse","role","init","urlObj","payload","search","searchParams","Request","port","prompt","callback","enableStaticServing","isStreamSupported","extendedRoutes","isLogger","_options","logger","app","express","cors","origin","methods","allowedHeaders","credentials","limit","urlencoded","extended","staticDir","process","cwd","staticUrlPath","get","req","res","esbuild","build","entryPoints","bundle","write","platform","loader",".tsx","format","target","jsx","send","outputFiles","text","status",".ts","extensions","setHeaders","statusCode","sendFile","post","_options2","stream","reader","_yield$reader$read","ping","setHeader","ReadableStream","getReader","read","end","finish","t2","_","_options3","route","handler","listen"],"mappings":"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"}