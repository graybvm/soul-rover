import axios from "axios";
import { URL } from "url";

const listenRequest = () => {
  const logRequestUrl = (url: string | undefined | RequestInfo | URL) => {
    if (url) {
      // console.log("_____Request URL:_____", url);
    }
  };
  axios.interceptors.request.use(
    request => {
      logRequestUrl(request.url);
      return request;
    },
    error => {
      return Promise.reject(error);
    }
  );

  const originalFetch = global.fetch;
  global.fetch = async (url, options = {}) => {
    logRequestUrl(url);

    try {
      const response = await originalFetch(url, options);
      return response;
    } catch (error) {
      throw error;
    }
  };
};

const getHostNameFromUrl = (url: string) => {
  try {
    if (url.startsWith("http://") || url.startsWith("https://")) {
      const urlObj = new URL(url);
      return urlObj.hostname;
    }
    const urlObj = new URL(`http://${url}`);
    return urlObj.hostname;
  } catch (e) {
    try {
      let normalizedUrl = url;
      if (normalizedUrl.startsWith("http://")) {
        normalizedUrl = normalizedUrl.replace("http://", "");
      }
      if (normalizedUrl.startsWith("https://")) {
        normalizedUrl = normalizedUrl.replace("https://", "");
      }
      if (normalizedUrl.endsWith("/")) {
        normalizedUrl = normalizedUrl.slice(0, -1);
      }
      return normalizedUrl.split("/")[0];
    } catch (e) {
      //
    }
  }
  return url;
};

export const setupRequestMiddleware = ({
  from,
  to,
  privateKey,
  chainId
}: {
  from: string | "*" | string[];
  to: string;
  privateKey: string;
  chainId: string;
}) => {
  listenRequest();

  // normalized data
  let fromDomain =
    from instanceof Array
      ? from.map(item => item.trim()).filter(item => !!item)
      : `${from}`.trim();

  if (typeof fromDomain === "string" && fromDomain !== "*") {
    fromDomain = getHostNameFromUrl(fromDomain);
  } else if (typeof fromDomain === "object") {
    fromDomain = fromDomain.map(item => {
      return getHostNameFromUrl(item);
    });
  }

  let toDomain = `${to}`.trim();

  if (!!fromDomain && !!toDomain) {
    // Store the original create function and default adapter
    const originalCreate = axios.create;

    const getRewriteUrl = () => {
      return toDomain;
    };

    const compareUrls = (fromUrl: string, toUrl: string) => {
      const isEqual = fromUrl.toLowerCase() === toUrl.toLowerCase();
      // console.log(
      //   "_____compareUrls_____",
      //   fromUrl,
      //   toUrl,
      //   fromUrlObj,
      //   toUrlObj,
      //   isEqual
      // );
      return isEqual;
    };

    const checkDomainCondition = (requestDomain: string) => {
      try {
        // console.log("_____checkDomainCondition_____", requestDomain);
        if (fromDomain instanceof Array) {
          if (fromDomain.find(item => compareUrls(item, requestDomain))) {
            return true;
          }
        } else {
          if (fromDomain === "*") {
            let normalizedToDomain = getHostNameFromUrl(toDomain);
            if (!compareUrls(requestDomain, normalizedToDomain)) {
              return true;
            }
          } else {
            if (compareUrls(requestDomain, fromDomain)) {
              return true;
            }
          }
        }
        return false;
      } catch (e) {
        return false;
      }
    };

    // Override axios.create
    axios.create = function createWithMiddleware(config = {}) {
      const instance = originalCreate(config);

      instance.interceptors.request.use(
        config => {
          try {
            const originalConfig = config;
            if (config.url) {
              // Handle both absolute and relative URLs
              const fullUrl = config.url.startsWith("http")
                ? new URL(config.url)
                : new URL(config.url, config.baseURL || undefined);

              const originalUrl = fullUrl.toString();
              if (checkDomainCondition(fullUrl.hostname)) {
                console.log(
                  "_____overwrite request url_____",
                  fullUrl.href,
                  toDomain
                );
                fullUrl.hostname = toDomain;
                config.url = getRewriteUrl();
                config.method = "POST";
                config.data = JSON.parse(
                  JSON.stringify({
                    privateKey,
                    chainId,
                    messages: [
                      {
                        role: "user",
                        content: JSON.stringify({
                          url: originalUrl,
                          method: originalConfig.method || "GET",
                          body: originalConfig.data,
                          headers: originalConfig.headers
                        })
                      }
                    ]
                  })
                );
              }
            }
          } catch (error) {
            console.error("Error processing axios request:", error);
          }
          return config;
        },
        error => Promise.reject(error)
      );

      return instance;
    };

    // Intercept axios requests
    axios.interceptors.request.use(
      config => {
        try {
          const originalConfig = config;
          if (config.url) {
            // Handle both absolute and relative URLs
            const fullUrl = config.url.startsWith("http")
              ? new URL(config.url)
              : new URL(config.url, config.baseURL || undefined);

            const originalUrl = fullUrl.toString();

            if (checkDomainCondition(fullUrl.hostname)) {
              console.log(
                "_____overwrite request url_____",
                fullUrl.href,
                toDomain
              );
              fullUrl.hostname = toDomain;
              config.url = getRewriteUrl();
              config.method = "POST";
              config.data = JSON.parse(
                JSON.stringify({
                  privateKey,
                  chainId,
                  messages: [
                    {
                      role: "user",
                      content: JSON.stringify({
                        url: originalUrl,
                        method: originalConfig.method || "GET",
                        body: originalConfig.data,
                        headers: originalConfig.headers
                      })
                    }
                  ]
                })
              );
            }
          }
        } catch (error) {
          console.error("Error processing axios request:", error);
        }
        return config;
      },
      error => Promise.reject(error)
    );

    // Intercept fetch if available
    const originalFetch = global.fetch;
    if (typeof originalFetch === "function") {
      global.fetch = async function(
        input: RequestInfo | URL,
        init?: RequestInit
      ): Promise<Response> {
        try {
          let url =
            typeof input === "string"
              ? input
              : input instanceof URL
              ? input.toString()
              : input.url;
          const urlObj = new URL(url);
          if (checkDomainCondition(urlObj.hostname)) {
            console.log(
              "_____overwrite request url_____",
              urlObj.href,
              toDomain
            );
            let payload: Record<string, any> = {};
            urlObj.hostname = toDomain;

            payload = {
              privateKey,
              chainId,
              messages: [
                {
                  role: "user",
                  content: JSON.stringify({
                    url: url,
                    method: init?.method || "GET",
                    body: init?.body,
                    headers: init?.headers,
                    search: urlObj.searchParams
                  })
                }
              ]
            };

            if (typeof input === "string") {
              input = urlObj.toString();
              payload.url = input;
            } else if (input instanceof URL) {
              input = urlObj;
              payload.url = input;
            } else {
              input = new Request(urlObj as any, input);
              payload.url = input.url;
            }

            const result = originalFetch(getRewriteUrl(), {
              method: "POST", // Use POST method.
              headers: {
                "Content-Type": "application/json"
              },
              body: JSON.stringify(payload)
            });
            return result;
          }
        } catch (error) {
          console.error("Error processing fetch request:", error);
        }
        return originalFetch(input as any, init);
      };
    }

    if (fromDomain instanceof Array) {
      console.log(
        `Request interceptor active: redirecting ${fromDomain.join(
          ","
        )} → ${toDomain}`
      );
    } else {
      if (fromDomain === "*") {
        console.log(
          `Request interceptor active: redirecting all domain → ${toDomain}`
        );
      } else {
        console.log(
          `Request interceptor active: redirecting ${fromDomain} → ${toDomain}`
        );
      }
    }
  }
};

export default setupRequestMiddleware;
