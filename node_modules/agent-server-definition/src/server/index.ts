// import express, { Request, Response } from "express";
import express, { Express } from "express";
import cors from "cors";
import path from "path";
import esbuild from "esbuild";
import { PromptFunction, RequestPromptPayload } from "../types";
import { Request, Response } from "express";

interface ServerOptions {
  staticDir?: string;
  staticUrlPath?: string;
  enableStaticServing?: boolean;
  logger?: boolean; // default is false
  isStreamSupported?: boolean;

  extendedRoutes?: {
    path: string;
    method: "GET" | "POST" | "PUT" | "DELETE";
    handler: (req: Request, res: Response) => void;
  }[];
}
export const startServer = (
         port: number,
         prompt: PromptFunction,
         options: ServerOptions = {
           enableStaticServing: false,
           isStreamSupported: false,
           extendedRoutes: []
         },
         callback?: (error?: Error) => void
       ): Express => {
         const isLogger = options?.logger || false;
         const app = express();

         if (!port) {
           throw new Error("Port is required");
         }

         if (!prompt) {
           throw new Error("Prompt function is required");
         }

         app.use(
           cors({
             origin: "*",
             methods: "*",
             allowedHeaders: "*",
             credentials: true
           })
         );
         app.use(express.json({ limit: "50mb" }));
         app.use(express.urlencoded({ extended: true })); // For form data
         app.options("*", cors());

         // Serve static files if enabled
         if (!!options.enableStaticServing) {
           const staticDir =
             options.staticDir || path.join(process.cwd(), "public");
           const staticUrlPath = options.staticUrlPath || "/";

           console.log(
             `Serving static files from: ${staticDir} at path: ${staticUrlPath}`
           );

           // Handle .tsx manually
           app.get("/*.tsx", async (req, res) => {
             const staticDir =
               options.staticDir || path.join(process.cwd(), "public");
             const filePath = path.join(staticDir, req.path);

             try {
               const result = await esbuild.build({
                 entryPoints: [filePath],
                 bundle: true,
                 write: false,
                 platform: "browser",
                 loader: { ".tsx": "tsx" },
                 format: "esm",
                 target: ["esnext"],
                 jsx: "automatic"
               });

               res
                 .type("application/javascript")
                 .send(result.outputFiles[0].text);
             } catch (err) {
               console.error(`TSX build error:`, err);
               res
                 .status(500)
                 .send(`Error building TSX: ${(err as any).message}`);
             }
           });

           // Handle .ts manually
           app.get("/*.ts", async (req, res) => {
             const staticDir =
               options.staticDir || path.join(process.cwd(), "public");
             const filePath = path.join(staticDir, req.path);

             try {
               const result = await esbuild.build({
                 entryPoints: [filePath],
                 bundle: true,
                 write: false,
                 platform: "browser",
                 loader: { ".ts": "ts" },
                 format: "esm",
                 target: ["esnext"]
               });

               res
                 .type("application/javascript")
                 .send(result.outputFiles[0].text);
             } catch (err) {
               console.error(`TS build error:`, err);
               res
                 .status(500)
                 .send(`Error building TS: ${(err as any).message}`);
             }
           });

           // Serve static files, but ignore .tsx files
           // Serve static files normally
           app.use(
             staticUrlPath,
             express.static(staticDir, {
               extensions: ["html"],
               setHeaders: (res: any, filePath) => {
                 // <-- FIXED TYPE HERE
                 if (filePath.endsWith(".tsx")) {
                   res.statusCode = 404;
                 }
               }
             })
           );

           // Fallback for SPA routing (optional)
           if (staticUrlPath === "/" && path.join(staticDir, "index.html")) {
             app.get("*", (req, res, next) => {
               if (
                 req.path.startsWith("/api") ||
                 req.path.startsWith("/prompt")
               ) {
                 next();
               } else {
                 res.sendFile(path.join(staticDir, "index.html"));
               }
             });
           }
         }

         app.post(
           "/prompt",
           // async (req: Request<{}, {}, RequestPromptPayload>, res: Response) => {
           async (req: any, res: any) => {
             const payload: RequestPromptPayload = req.body;
             if (isLogger) {
               console.log("prompt: payload", payload);
             }
             try {
               if (!!payload.ping) {
                 res.send("online");
               } else {
                 if (!!options?.isStreamSupported && payload.stream) {
                   // Set headers for SSE
                   res.setHeader("Content-Type", "text/event-stream");
                   res.setHeader("Cache-Control", "no-cache");
                   res.setHeader("Connection", "keep-alive");

                   // Stream the response
                   try {
                     const stream = await prompt(payload);
                     if (stream instanceof ReadableStream) {
                       const reader = stream.getReader();

                       try {
                         while (true) {
                           const { done, value } = await reader.read();
                           if (done) {
                             break;
                           }
                           // Forward the chunk directly as it's already formatted as SSE
                           res.write(value);
                         }
                       } catch (error) {
                         console.error("Stream reading error:", error);
                         res.write(
                           `data: ${JSON.stringify({
                             error: (error as Error).message
                           })}\n\n`
                         );
                       } finally {
                         res.end();
                       }
                     } else {
                       // For non-stream responses, format as SSE
                       res.write(`data: ${JSON.stringify(stream)}\n\n`);
                       res.write("data: [DONE]\n\n");
                       res.end();
                     }
                   } catch (error) {
                     console.error("Stream processing error:", error);
                     res.write(
                       `data: ${JSON.stringify({
                         error: (error as Error).message
                       })}\n\n`
                     );
                     res.end();
                   }
                 } else {
                   // Non-streaming response
                   const result = await prompt(payload);
                   if (isLogger) {
                     console.log("prompt: result", result);
                   }
                   res.json(result);
                 }
               }
             } catch (error) {
               console.log("prompt: error", error);
               res.status(500).json({ error: (error as Error).message });
             }
           }
         );

         // Add health check endpoint
         app.get("/health", (_: any, res: any) => {
           res.status(200).json({ status: "ok" });
         });

         try {
           options?.extendedRoutes?.forEach(route => {
             try {
               app[route.method.toLowerCase()](route.path, route.handler);
             } catch (e) {
               console.error("Error adding extended routes:", e);
             }
           });
         } catch (e) {
           console.error("Error adding extended routes:", e);
         }

         const defaultCallback = (error?: Error) => {
           if (error) {
             console.error(`Error starting server:`, error);
             return;
           }
           console.log(`Server is running on http://localhost:${port}`);
           if (callback) {
             callback(error);
           }
         };

         app.listen(port, defaultCallback);
         return app;
       };
