import fs from "fs";
import path from "path";
import { Base64Result, Message } from "../types";

export const getBaseFromBase64 = (
  type: string,
  messages: Message[]
): Base64Result[] => {
  const result: Base64Result[] = [];
  messages.forEach(message => {
    if (Array.isArray(message.content)) {
      message.content.forEach(contentItem => {
        if (contentItem.type === type) {
          const [contentType, base64] = contentItem[type].url.split(",");
          result.push({
            type: contentType.split(":")[1].split(";")[0],
            base64: base64,
            fileName: contentItem[type].detail
          });
        }
      });
    }
  });
  return result;
};

/**
 * Detect file type from binary data using magic numbers
 * @param buffer - Buffer containing the file data
 * @returns File type info {mime: string, ext: string} or null if unknown
 */
/**
 * Detect file type from binary data or MIME type string
 * @param input - Either a Buffer containing file data or a MIME type string
 * @returns File type info {mime: string, ext: string} or null if unknown
 */
const detectFileType = (mime: string): string | null => {
  // If input is a string, assume it's a MIME type
  const mimeType = mime.toLowerCase().trim();

  // Common MIME types to extension mapping
  const mimeMapping: Record<string, string> = {
    "image/png": "png",
    "image/jpeg": "jpg",
    "image/jpg": "jpg",
    "image/gif": "gif",
    "image/webp": "webp",
    "image/svg+xml": "svg",
    "application/pdf": "pdf",
    "audio/mpeg": "mp3",
    "audio/mp3": "mp3",
    "video/mp4": "mp4",
    "video/mpeg": "mpg",
    "application/json": "json",
    "text/plain": "txt",
    "text/html": "html",
    "text/css": "css",
    "text/javascript": "js",
    "application/javascript": "js",
    "application/xml": "xml",
    "text/xml": "xml",
    "application/zip": "zip",
    "application/x-zip-compressed": "zip",
    "application/msword": "doc",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
      "docx",
    "application/vnd.ms-excel": "xls",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": "xlsx",
    "application/vnd.ms-powerpoint": "ppt",
    "application/vnd.openxmlformats-officedocument.presentationml.presentation":
      "pptx"
  };

  // Return known extension or extract from MIME type
  if (mimeMapping[mimeType]) {
    return mimeMapping[mimeType];
  }

  return null;
};

export const parseDataUrl = (
  dataUrl: string
): { mimeType: string; base64: string; buffer: Buffer } | null => {
  if (!dataUrl || typeof dataUrl !== "string") {
    return null;
  }

  // Check if this is a valid data URL format
  const dataUrlRegex = /^data:([^;,]+)(;base64)?,(.*)/;
  const matches = dataUrl.match(dataUrlRegex);

  if (!matches || matches.length < 4) {
    return null;
  }

  return {
    mimeType: matches[1],
    base64: matches[3],
    buffer: Buffer.from(matches[3], "base64")
  };
};

/**
 * Creates a file from base64 data
 * @param base64 - The base64 string (without the data:image/png;base64, prefix)
 * @param fileName - Name for the created file
 * @param directory - Directory to store the file (default: 'tmp')
 * @param fileType - Optional MIME type (e.g., 'image/png')
 * @returns Promise with the full path to the created file
 */
export const createFileFromBase64 = async (
  base64: string,
  fileName: string,
  directory: string = "tmp"
): Promise<string> => {
  // Create directory if it doesn't exist
  await fs.promises.mkdir(directory, { recursive: true });

  // Convert base64 to buffer
  // const buffer = Buffer.from(base64, "base64");

  const data = parseDataUrl(base64);
  if (!data) {
    throw new Error("Invalid base64 data");
  }
  const { mimeType, buffer } = data;
  // Auto-detect file type from buffer
  const extension = mimeType ? detectFileType(mimeType) : "";

  // Create a safe filename if not provided
  let safeFileName =
    fileName ||
    `file-${Date.now()}-${Math.random()
      .toString(36)
      .substring(2, 10)}`;

  // Add extension if not present in the filename
  if (path.extname(safeFileName) === "") {
    safeFileName = `${safeFileName}.${extension}`;
  }

  // Generate file path
  const filePath = path.join(directory, safeFileName);

  // Write buffer to file
  await fs.promises.writeFile(filePath, buffer);

  // Return the full path
  return filePath;
};

/**
 * Creates files from the results of getBaseFromBase64
 * @param results - Array of Base64Result objects
 * @param directory - Directory to store the files (default: 'tmp')
 * @returns Promise with array of file paths
 */
export const createFilesFromBase64Results = async (
  results: Base64Result[],
  directory: string = "tmp"
): Promise<string[]> => {
  const filePaths: string[] = [];

  for (const result of results) {
    // Pass file type to createFileFromBase64
    const filePath = await createFileFromBase64(
      result.base64,
      result.fileName ||
        `file-${Date.now()}-${Math.random()
          .toString(36)
          .substring(2, 10)}`,
      directory
    );
    filePaths.push(filePath);
  }

  return filePaths;
};

/**
 * Deletes a file if it exists
 * @param filePath - Path to the file to delete
 * @returns Promise<boolean> - True if file was deleted, false if file didn't exist
 */
export const deleteFile = async (filePath: string): Promise<boolean> => {
  try {
    // Check if file exists
    await fs.promises.access(filePath);

    // Delete the file
    await fs.promises.unlink(filePath);
    return true;
  } catch (error) {
    // File doesn't exist or other error
    if ((error as any).code === "ENOENT") {
      return false;
    }
    // Re-throw unexpected errors
    throw error;
  }
};

/**
 * Deletes multiple files
 * @param filePaths - Array of file paths to delete
 * @returns Promise<{deleted: string[], notFound: string[], failed: {path: string, error: string}[]}>
 */
export const deleteFiles = async (
  filePaths: string[]
): Promise<{
  deleted: string[];
  notFound: string[];
  failed: Array<{ path: string; error: string }>;
}> => {
  const results = {
    deleted: [] as string[],
    notFound: [] as string[],
    failed: [] as Array<{ path: string; error: string }>
  };

  await Promise.all(
    filePaths.map(async filePath => {
      try {
        const deleted = await deleteFile(filePath);
        if (deleted) {
          results.deleted.push(filePath);
        } else {
          results.notFound.push(filePath);
        }
      } catch (error) {
        results.failed.push({
          path: filePath,
          error: (error as any).message || String(error)
        });
      }
    })
  );

  return results;
};

/**
 * Cleans up temporary files in a directory
 * @param directory - Directory to clean
 * @param maxAge - Maximum age of files to keep (in milliseconds)
 * @returns Promise with deletion results
 */
export const cleanupTempFiles = async (
  directory: string = "tmp",
  maxAge: number = 24 * 60 * 60 * 1000 // Default: 24 hours
): Promise<{
  deleted: string[];
  notFound: string[];
  failed: Array<{ path: string; error: string }>;
}> => {
  try {
    // Check if directory exists
    await fs.promises.access(directory);

    // Get all files in directory
    const files = await fs.promises.readdir(directory);
    const now = Date.now();
    const filesToDelete: string[] = [];

    // Check each file's age
    for (const file of files) {
      const filePath = path.join(directory, file);
      try {
        const stats = await fs.promises.stat(filePath);
        const fileAge = now - stats.mtimeMs;

        if (fileAge > maxAge) {
          filesToDelete.push(filePath);
        }
      } catch (error) {
        console.error(`Error checking file ${filePath}:`, error);
      }
    }

    // Delete old files
    return await deleteFiles(filesToDelete);
  } catch (error) {
    if ((error as any).code === "ENOENT") {
      return { deleted: [], notFound: [], failed: [] };
    }
    throw error;
  }
};

/**
 * Checks if a string is base64 encoded
 * @param str - The string to check
 * @param strict - Whether to perform strict validation (including decoding test)
 * @returns boolean - True if the string is base64 encoded, false otherwise
 */
export const isBase64 = (str: string, strict: boolean = false): boolean => {
  if (!str || typeof str !== "string") {
    return false;
  }

  // Check 1: String only contains valid base64 characters
  const base64Regex = /^[A-Za-z0-9+/]*={0,2}$/;
  if (!base64Regex.test(str)) {
    return false;
  }

  // Check 2: Length is valid (multiple of 4)
  if (str.length % 4 !== 0) {
    return false;
  }

  // Check 3: Padding (=) only appears at the end and at most 2
  const paddingMatch = str.match(/=*$/);
  if (paddingMatch && paddingMatch[0].length > 2) {
    return false;
  }

  // Check 4: If strict mode, try to decode it
  if (strict) {
    try {
      Buffer.from(str, "base64").toString();
      return true;
    } catch (error) {
      return false;
    }
  }

  return true;
};

/**
 * Checks if a string is a data URL
 * @param str - The string to check
 * @returns boolean - True if the string is a data URL, false otherwise
 */
export const isDataUrl = (str: string): boolean => {
  if (!str || typeof str !== "string") {
    return false;
  }

  const dataUrlRegex = /^data:([^;,]+)(;base64)?,/;
  return dataUrlRegex.test(str);
};

/**
 * Detects if a string is base64 or data URL and extracts base64 content
 * @param input - The string to check (could be base64 encoded string or data URL)
 * @returns Object with type and content, or null if not recognized
 */
export const parseBase64Input = (
  input: string
): {
  type: "base64" | "dataUrl";
  content: string;
  mimeType?: string;
} | null => {
  if (!input || typeof input !== "string") {
    return null;
  }

  // Check if it's a data URL
  if (isDataUrl(input)) {
    const parsed = parseDataUrl(input);
    if (!parsed) return null;

    return {
      type: "dataUrl",
      content: parsed.base64,
      mimeType: parsed.mimeType
    };
  }

  // Check if it's a plain base64 string
  if (isBase64(input)) {
    return {
      type: "base64",
      content: input
    };
  }

  return null;
};
